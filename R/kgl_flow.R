#' Kaggle Flow
#'
#' This is an **experimental** and **opinionated** reproducible workflow for working with kaggle competitions. The Kaggle Flow will always check  if the competition rules are accepted and the data files for the competition are readily available. If they are not, they will be downloaded.
#'
#' If `id` is NULL this function will check to see if there is a previously recorded competition ID in the metadata. This will only exist if `kgl_flow()` was ran  in the past for the current R project.
#'
#' @inheritParams kgl_competitions_data_list
#'
#' @return Nothing.
#' @export
#' @family Kaggle Flows
#'
#' @examples
#' \dontrun{
#' library(kaggler)
#'
#' kgl_flow("titanic")
#' }
kgl_flow <- function(id = NULL) {
  if (is.null(id) && fs::file_exists(path_competition_id)) {
    id <- readLines(path_competition_id)[2]
  }

  if (!assertthat::is.string(id)) {
    usethis::ui_oops("{usethis::ui_value('id')} must be a character that references the competition. Check the docs for {usethis::ui_value('kgl_flow()')} for an acceptable {usethis::ui_value('id')}.")

    return(invisible())
  }

  competition_id <- id_type_guesser(id)

  if (validate_input_competition_id(competition_id)) {
    usethis::ui_oops("Invalid competition id input.")
    return(invisible())
  }

  dir_path <- usethis::proj_path(.kgl_dir)

  fs::dir_create(dir_path)

  dir_meta <- fs::path(dir_path, "meta")
  path_meta <- fs::path(dir_meta, "meta")
  path_competition_id <- fs::path(dir_meta, "competition_id")

  if (fs::file_exists(path_competition_id)) {
    logged_competition_id <- readLines(path_competition_id)[2]

    if (logged_competition_id != competition_id) {
      user_response <- usethis::ui_yeah(
        "The previously used competition_id is not the same as the input id. It is recommended that there is one Rproj per kaggle competition. Do yo want to clear the content of {.kgl_dir_ui}?
        - Recorded ID: {usethis::ui_value(logged_competition_id)}
        - Clean Input ID: {usethis::ui_value(competition_id)}"
      )

      if (user_response) {
        fs::dir_delete(dir_path)

        fs::dir_create(dir_path)
        fs::dir_create(dir_meta)

        usethis::write_union(
          path = path_competition_id,
          lines = c(
            "# Generated by kaggler: do not edit by hand",
            competition_id
          ),
          quiet = TRUE
        )
      } else {
        usethis::ui_oops(
          "{usethis::ui_value('kgl_flow()')} depends on the previously used competition ID being the same as the input. To proceed do one of thoe following:
          - Update the input ID to the previous value
          - Re-run {usethis::ui_value('kgl_flow()')} and choose to remove the contents in {.kgl_dir_ui}
          - Start a new R project."
        )
        return(invisible())
      }
    }
  } else {
    fs::dir_create(dir_meta)

    usethis::write_union(
      path = path_competition_id,
      lines = c(
        "# Generated by kaggler: do not edit by hand",
        competition_id
      ),
      quiet = TRUE
    )
  }

  data_list <- kgl_competitions_data_list(
    id = competition_id
  ) %>%
    dplyr::mutate(
      name_old = name,
      name = fs::path_ext_remove(name)
    ) %>%
    dplyr::arrange(total_bytes)

  v_file_names <- dplyr::pull(data_list, name, ref)

  current_id <- unique(data_list$id)

  rules_check <- kgl_flow_rules_check(competition_id, names(v_file_names)[1])

  if (!rules_check) {
    competition_url <- glue::glue("{.kaggle_competition_url}{competition_id}/rules")
    competition_url_ui <- usethis::ui_value(competition_url)
    user_check <- usethis::ui_yeah("Would you like to visit {competition_url_ui} to accept the rules?")

    if (user_check) {
      browseURL(competition_url)
    }

    usethis::ui_todo("Rerun {usethis::ui_value('kgl_flow()')} once the rules are accepted!")
    return(invisible())
  }

  files_to_check <- fs::path(dir_path, data_list$name_old)

  v_to_download <-
    data_list %>%
    dplyr::pull(ref, name) %>%
    .[!fs::file_exists(files_to_check)]

  v_not_download <-
    data_list %>%
    dplyr::pull("ref") %>%
    .[fs::file_exists(files_to_check)]

  if (length(v_to_download) > 0) {
    if (length(v_not_download) > 0) {
      v_already_downloaded <-
        v_not_download %>%
        fs::path_ext_remove() %>%
        ui_ul()

      usethis::ui_info(
        "These files are detected in {.kgl_dir_ui} and will not be downloaded:
        {v_already_downloaded}"
      )
    }

    v_needs_to_download <-
      v_to_download %>%
      fs::path_ext_remove() %>%
      ui_ul()

    usethis::ui_todo(
      "These files will be downloaded:
      {v_needs_to_download}."
    )

    d_info <-
      v_to_download %>%
      purrr::map_dfr(~ {
        d <- kgl_flow_data_download(
          competition_id = current_id,
          file_name = .x,
          dir_name = dir_path
        )

        return(d)
      })

    ## Create/Update metadata
    if (fs::file_exists(path_meta)) {
      d_meta <- readRDS(path_meta)

      d_old <-
        d_meta %>%
        dplyr::filter(!ref %in% d_info$name)

      d_to_add <-
        data_list %>%
        dplyr::filter(ref %in% d_info$name) %>%
        dplyr::left_join(
          y = d_info,
          by = "name"
        )

      d_old %>%
        dplyr::bind_rows(d_to_add) %>%
        saveRDS(file = path_meta)
    } else {
      data_list %>%
        dplyr::mutate(name = name_old) %>%
        dplyr::select(-name_old) %>%
        dplyr::left_join(
          y = d_info,
          by = "name"
        ) %>%
        saveRDS(file = path_meta)
    }
  } else {
    usethis::ui_todo("All data files already exist in {.kgl_dir_ui}.")
  }

  return(invisible())
}

validate_input_competition_id <- function(competition_id) {
  get_url <- glue::glue("competitions/data/list/{competition_id}")

  get_request <- suppressMessages(kgl_api_get(get_url))

  return(get_request$status_code != 200)
}

kgl_flow_data_download <- function(
  competition_id,
  file_name,
  dir_name
) {
  get_url <- glue::glue("competitions/data/download/{competition_id}/{file_name}")

  get_request <- kgl_api_get(get_url)

  if (httr::status_code(get_request) != 200) {
    return(invisible(get_request))
  }

  get_url <- get_request$url

  get_ext <- fs::path_ext(get_url)

  path_temp <- fs::path(
    dir_name,
    file_name %>% fs::path_ext_remove(),
    ext = get_ext
  )

  file_name_value <- usethis::ui_value(file_name)
  usethis::ui_todo("Downloading {file_name_value}...")

  download.file(
    url = get_url,
    destfile = path_temp,
    mode = "wb",
    quiet = TRUE
  )

  if (get_ext == "zip") {
    usethis::ui_todo("Zip file detected! Unzipping...")

    unzip_result <- suppressWarnings(unzip(
      path_temp,
      exdir = dir_name,
      overwrite = TRUE
    ))

    fs::file_delete(path_temp)
  }

  path_d <- fs::path(dir_name, file_name)

  if (!fs::file_exists(path_d)) {
    usethis::ui_oops("File does not exist! Something went wrong :(")
    return(NULL)
  }

  path_ext <- fs::path_ext(path_d)

  if (path_ext == "csv") {
    d <- shh(readr::read_csv(
      file = path_d,
      col_types = readr::cols(),
      progress = FALSE
    ))
    d_rows <- nrow(d)
    d_cols <- ncol(d)
  } else {
    d_rows <- NA_integer_
    d_cols <- NA_integer_
  }

  d_meta <-
    dplyr::tibble(
      name = file_name,
      download_time = shh(lubridate::now()),
      nrows = d_rows,
      ncols = d_cols
    )

  return(invisible(d_meta))
}

#' Read the project's metadata
#'
#' Read the metadata of the competitions datasets.
#'
#' @return A data frame with one row per competition dataset.
#' @export
#' @family Kaggle Flows
#'
#' @examples
#' \dontrun{
#' library(kaggler)
#'
#' kgl_flow("titanic")
#'
#' kgl_flow_meta()
#' }
kgl_flow_meta <- function() {
  dir_meta <- fs::path(.kgl_dir, "meta")
  path_meta <- fs::path(dir_meta, "meta")
  path_meta_id <- fs::path(dir_meta, "competition_id")

  if (fs::file_exists(path_meta) && fs::file_exists(path_meta_id)) {
    if (identical(parent.frame(n = 1), globalenv())) {
      usethis::ui_info("Competition ID: {usethis::ui_value(readLines(path_meta_id)[2])}")
    }

    readRDS(path_meta)
  } else {
    ui_kgl_flow <- usethis::ui_value("kgl_flow()")
    usethis::ui_todo("metadata files does not exist. Do you need to execute {ui_kgl_flow}?")
  }
}

kgl_flow_rules_check <- function(competition_id, file_name) {
  get_url <- glue::glue("competitions/data/download/{competition_id}/{file_name}")

  get_request <- kgl_api_get(get_url)

  invisible(get_request$status_code == 200)
}

ui_ul <- function(x) {
  x %>%
    purrr::map_chr(~ {
      paste0("- ", usethis::ui_value(.x))
    }) %>%
    glue::glue_collapse("\n")
}

#' Loan the Kaggle data
#'
#' If all of the files in `_kaggle_data` are in **csv** format (excluding the meta directory) then this function will load all of the kaggle data into the current environment (or the environment of your choosing) via `readr::read_csv()`.
#'
#' @param envir Environment to put the loaded kaggle data.
#'
#' @return Nothing.
#' @export
#' @family Kaggle Flows
#'
#' @examples
#' \dontrun{
#' library(kaggler)
#'
#' kgl_flow("titanic")
#'
#' kgl_flow_load()
#' }
kgl_flow_load <- function(envir = parent.frame()) {
  d_meta <- kgl_flow_meta()

  dir_kgl <- usethis::proj_path(.kgl_dir)

  files_to_check <- fs::dir_ls(
    path = dir_kgl,
    type = "file"
  )

  if (nrow(d_meta) != length(files_to_check)) {
    usethis::ui_oops("There seem to be files missing! Run {usethis::ui_value('kgl_flow()')} to make sure all files are present.")
    return(invisible())
  }

  if (all(stringr::str_detect(files_to_check, "\\.csv$"))) {
    v_files_to_iterate_over <- fs::dir_ls(dir_kgl, regexp = "\\.csv$")
    v_file_names <-
      v_files_to_iterate_over %>%
      fs::path_file() %>%
      fs::path_ext_remove()

    l_d <-
      v_files_to_iterate_over %>%
      purrr::set_names(v_file_names) %>%
      purrr::map(readr::read_csv, col_types = readr::cols()) %>%
      purrr::imap(~ {
        assign(
          x = .y,
          value = .x,
          env = envir
        )
      })

    v_file_names_ui <-
      v_file_names %>%
      purrr::map_chr(~ {
        paste0("- ", usethis::ui_value(.x))
      }) %>%
      glue::glue_collapse("\n")

    usethis::ui_done(
      "The data has been loaded into the global environment!
      {v_file_names_ui}"
    )
  } else {
    paths <-
      dir_kgl
    fs::dir_ls(type = "file") %>%
      ui_ul()

    usethis::ui_done(
      "Data is not in csv format. Use the following data paths to manually read in the wanted data.
      {paths}"
    )
  }

  return(invisible())
}
